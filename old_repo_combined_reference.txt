=======================================
FILE: src\types\sbhq.ts
=======================================

export type Role = 'admin' | 'user' | null;

export interface UserRow {
  id: string;
  username: string | null;
  email: string | null;
  role: Role;
  created_at: string;
  updated_at: string;
}

export interface ContestRow {
  id: string;
  name: string;
  current_round: number;
  finished: boolean;
  lobby_open: boolean;
  submission_open: boolean;
  start_time: string;
  price: number | null;
  created_at: string;
}

export interface ParticipantRow {
  id: string;
  contest_id: string;
  user_id: string;
  active: boolean;
  elimination_round: number | null;
}

export interface QuestionRow {
  id: string;
  contest_id: string;
  round: number;
  question: string;
  options: Record<string, string>;
  correct_option: string | null;
}

export interface AnswerRow {
  id: string;
  participant_id: string;
  contest_id: string;
  question_id: string;
  round: number;
  answer: string;
  timestamp: string;
}



=======================================
FILE: src\hooks\useCheckElimination.ts
=======================================

import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";
import { supabase } from "../supabase";

type ParticipantPayload = RealtimePostgresChangesPayload<{
  user_id?: string;
  active?: boolean;
}>;

const useCheckElimination = (contestId?: string, userId?: string) => {
  const navigate = useNavigate();

  useEffect(() => {
    if (!contestId || !userId) return;

    let unsubscribe: (() => void) | undefined;

    const checkElimination = async () => {
      try {
        const { data, error } = await supabase
          .from("participants")
          .select("active")
          .eq("contest_id", contestId)
          .eq("user_id", userId)
          .single();

        if (error) throw error;

        if (data?.active === false) {
          navigate("/eliminated");
        }

        const channel = supabase
          .channel(`participants-elimination-${contestId}`)
          .on(
            "postgres_changes",
            {
              event: "UPDATE",
              schema: "public",
              table: "participants",
              filter: `contest_id=eq.${contestId}`,
            },
            (payload: ParticipantPayload) => {
              const newRow = payload.new as { user_id?: string; active?: boolean } | null;
              if (newRow?.user_id === userId && newRow?.active === false) {
                navigate("/eliminated");
              }
            }
          )
          .subscribe();

        unsubscribe = () => {
          supabase.removeChannel(channel);
        };
      } catch (err) {
        console.error("Error checking participant status:", (err as Error).message);
      }
    };

    checkElimination();

    return () => {
      if (unsubscribe) unsubscribe();
    };
  }, [contestId, userId, navigate]);

  return null;
};

export default useCheckElimination;



=======================================
FILE: src\utils\realtime.ts
=======================================

import { useEffect } from 'react';
import type { RealtimePostgresChangesPayload, RealtimeChannel } from '@supabase/supabase-js';
import { supabase } from '../supabase';

type PostgresEvent = 'INSERT' | 'UPDATE' | 'DELETE' | '*';

interface RealtimeConfig {
  channelName: string;
  event: PostgresEvent;
  schema: string;
  table: string;
  filter?: string;
  callback: (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => void;
}

export function useRealtime({
  channelName,
  event,
  schema,
  table,
  filter,
  callback,
}: RealtimeConfig) {
  useEffect(() => {
    const channel = supabase.channel(channelName);
    const typedChannel = channel as unknown as {
      on: (
        event: 'postgres_changes',
        opts: { event: PostgresEvent; schema: string; table: string; filter?: string },
        cb: RealtimeConfig['callback']
      ) => RealtimeChannel;
      subscribe: () => void;
    };

    typedChannel.on('postgres_changes', { event, schema, table, filter }, callback).subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [channelName, event, schema, table, filter, callback]);
}



=======================================
FILE: src\supabase.ts
=======================================

import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.REACT_APP_SUPABASE_URL;
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  realtime: {
    params: {
      log_level: 'info', // Enable real-time connection logging
    },
  },
});



=======================================
FILE: src\contexts\AuthContext.tsx
=======================================

import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import type { Session, User } from "@supabase/supabase-js";
import { supabase } from "../supabase";

type Role = "admin" | "user" | null;

interface AuthContextValue {
  user: User | null;
  session: Session | null;
  role: Role;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextValue | null>(null);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [authState, setAuthState] = useState<Omit<AuthContextValue, "isLoading">>({
    user: null,
    session: null,
    role: null,
  });
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeAuth = async () => {
      try {
        const {
          data: { session },
          error,
        } = await supabase.auth.getSession();
        if (error) {
          throw error;
        }

        if (session?.user) {
          const { data, error: roleError } = await supabase
            .from("users")
            .select("role")
            .eq("id", session.user.id)
            .single();

          if (roleError) {
            throw new Error("Failed to fetch user role");
          }

          setAuthState({
            user: session.user,
            session: session,
            role: (data?.role as Role) ?? null,
          });
        } else {
          resetAuthState();
        }
      } catch (err) {
        console.error("Error initializing authentication:", (err as Error)?.message || err);
        resetAuthState();
      } finally {
        setIsLoading(false);
      }
    };

    initializeAuth();

    const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {
      if (session?.user) {
        setAuthState((current) => ({
          ...current,
          user: session.user,
          session: session,
          role: current.role || null,
        }));
      } else {
        resetAuthState();
      }
    });

    return () => {
      listener?.subscription?.unsubscribe();
    };
  }, []);

  const resetAuthState = () => {
    setAuthState({
      user: null,
      session: null,
      role: null,
    });
  };

  const value: AuthContextValue = { ...authState, isLoading };

  return (
    <AuthContext.Provider value={value}>
      {isLoading ? <div>Loading authentication...</div> : children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return ctx;
};



=======================================
FILE: src\contexts\UserContext.tsx
=======================================

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import { jwtDecode } from 'jwt-decode';

type DecodedUser = Record<string, unknown> | null;

interface UserContextValue {
  user: DecodedUser;
  loginUser: (token: string) => void;
  logoutUser: () => void;
}

const UserContext = createContext<UserContextValue | null>(null);

export const UserProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<DecodedUser>(() => {
    const token = localStorage.getItem('jwtToken');
    return token ? (jwtDecode(token) as DecodedUser) : null;
  });

  const loginUser = useCallback((token: string) => {
    localStorage.setItem('jwtToken', token);
    const decoded = jwtDecode(token) as DecodedUser;
    setUser(decoded);
  }, []);

  const logoutUser = useCallback(() => {
    localStorage.removeItem('jwtToken');
    setUser(null);
  }, []);

  return (
    <UserContext.Provider value={{ user, loginUser, logoutUser }}>
      {children}
    </UserContext.Provider>
  );
};

export const useUser = () => {
  const ctx = useContext(UserContext);
  if (!ctx) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return ctx;
};



=======================================
FILE: src\screens\Auth\AuthScreen.tsx
=======================================

import React from "react";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import AuthForm from "../../components/AuthForm/AuthForm";
import styles from "./AuthScreen.module.css";

function AuthScreen() {
  return (
    <div className={styles.authScreen}>
      <div className={styles.header}>
        <Header />
      </div>
      <div className={styles.screenContent}>
        <MainText header="Welcome!" subheader="Sign in to continue." />
        <AuthForm />
      </div>
    </div>
  );
}

export default AuthScreen;



=======================================
FILE: src\screens\JoinContests\JoinContestsScreen.tsx
=======================================

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import Header from "../../components/Header/Header";
import ContestCard from "../../components/ContestCard/ContestCard";
import styles from "./JoinContestsScreen.module.css";
import { supabase } from "../../supabase";
import { useAuth } from "../../contexts/AuthContext";
import type { ContestRow, ParticipantRow } from "../../types/sbhq";

type ContestWithParticipants = ContestRow & { participants?: Array<Partial<ParticipantRow>> };

function JoinContestsScreen() {
  const navigate = useNavigate();
  const { user } = useAuth(); // Get the user from the updated AuthContext
  const [contests, setContests] = useState<ContestWithParticipants[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true); // Track loading state

  // Fetch contests initially
  useEffect(() => {
    const fetchContests = async () => {
      if (!user) {
        setError("User is not authenticated.");
        setIsLoading(false);
        return;
      }

      try {
        const { data, error } = await supabase
          .from("contests")
          .select(`
            id,
            name,
            start_time,
            lobby_open,
            participants:participants(user_id, active)
          `)
          .order("start_time", { ascending: true });

        if (error) throw error;

        setContests((data as ContestWithParticipants[]) || []);
      } catch (err) {
        console.error("Failed to fetch contests:", (err as Error).message);
        setError("Failed to load contests. Please try again later.");
      } finally {
        setIsLoading(false);
      }
    };

    fetchContests();
  }, [user]);

  useEffect(() => {
    let isRedirected = false; // Track redirection state

    const checkOpenLobbies = async () => {
      if (isRedirected) return; // Stop polling after redirect

      try {
        // Step 1: Fetch contests where the user is a participant
        const { data: userContests, error: participantsError } = await supabase
          .from("participants")
          .select("contest_id")
          .eq("user_id", user?.id);

        if (participantsError) throw participantsError;

        if (userContests.length === 0) {
          // User is not registered for any contests
          return;
        }

        // Step 2: Extract contest IDs from the user's participants data
        const contestIds = userContests.map((p) => p.contest_id);

        // Step 3: Fetch open lobbies among the contests the user is registered for
        const { data: openContests, error: contestsError } = await supabase
          .from("contests")
          .select("*")
          .in("id", contestIds) // Narrow search to only relevant contest IDs
          .eq("lobby_open", true);

        if (contestsError) throw contestsError;

        if (openContests && openContests.length > 0) {
          // Redirect to the lobby of the first open contest
          isRedirected = true; // Mark as redirected
          navigate("/lobby", { state: { contest: openContests[0] } });
        }
      } catch (err) {
        console.error("Failed to check open lobbies:", (err as Error).message);
      }
    };

    // Check immediately on mount
    checkOpenLobbies();

    // Then set up polling
    const interval = setInterval(checkOpenLobbies, 10000);

    return () => clearInterval(interval);
  }, [navigate, user]);

  // Handle joining a contest
  const handleJoinContest = async (contestId: string) => {
    if (!user) {
      setError("User is not authenticated. Please log in again.");
      return;
    }

    try {
      const { error } = await supabase
        .from("participants")
        .insert({
          contest_id: contestId,
          user_id: user.id, // Supabase user ID from AuthContext
          active: true,
        });

      if (error) throw error;

      // Update local state
      setContests((prevContests) =>
        prevContests.map((contest) =>
          contest.id === contestId
            ? {
                ...contest,
                participants: [
                  ...(contest.participants || []),
                  { user_id: user.id, active: true },
                ],
              }
            : contest
        )
      );
    } catch (err) {
      console.error("Failed to join contest:", (err as Error).message);
      setError("Failed to join contest. Please try again later.");
    }
  };

  // Check if the user is registered
  const isUserRegistered = (contest: ContestWithParticipants) => {
    return (
      Array.isArray(contest.participants) &&
      contest.participants.some((participant) => participant?.user_id === user?.id)
    );
  };

  if (isLoading) {
    return <div>Loading contests...</div>;
  }

  return (
    <div className={styles.joinContestsScreen}>
      <div className={styles.pregameHeader}>
        <Header />
      </div>
      <div className={styles.screenContent}>
        <h1 className={styles.contestHeader}>Contests</h1>
        {error && <p className={styles.error}>{error}</p>}
        <div className={styles.contestList}>
          {contests.map((contest) => (
            <ContestCard
              key={contest.id}
              contest={contest}
              onJoin={handleJoinContest}
              isRegistered={isUserRegistered(contest)}
            />
          ))}
        </div>
      </div>
    </div>
  );
}

export default JoinContestsScreen;



=======================================
FILE: src\screens\Pregame\PregameScreen.tsx
=======================================

import React from "react";
import MainText from "../../components/MainText/MainText";
import Header from "../../components/Header/Header";

import pregameGif from "../../assets/catch_nobg.gif";

import styles from "./PregameScreen.module.css";

function PregameScreen() {
  return (
    <div className={styles.pregameScreen}>
      <div className={styles.pregameHeader}>
        <Header />
      </div>
      <div className={styles.screenContent}>
        <MainText
          header="Starting Soon"
          subheader="Make sure to join the Whatsapp group to stay updated!"
        />
        <img
          src={pregameGif}
          alt="Pregame Gif"
          className={styles.pregameGif}
          style={{ width: 250, height: 250 }}
        />
      </div>
    </div>
  );
}

export default PregameScreen;



=======================================
FILE: src\screens\Lobby\LobbyScreen.tsx
=======================================

import React, { useState, useEffect, useCallback } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import PlayerList from "../../components/PlayersList/PlayersList";
import styles from "./LobbyScreen.module.css";
import { supabase } from "../../supabase";
import type { ContestRow } from "../../types/sbhq";

function LobbyScreen() {
  const location = useLocation();
  const navigate = useNavigate();
  const { contest } = (location.state || {}) as { contest?: ContestRow }; // Access contest object directly from location state
  const gradientStyle = "linear-gradient(167deg, #54627B, #303845)";
  const [players, setPlayers] = useState<string[]>([]);
  const [timeRemaining, setTimeRemaining] = useState(0);

  const fetchParticipants = useCallback(async () => {
    if (!contest?.id) {
      console.error("Contest ID is missing");
      return;
    }

    try {
      const { data, error } = await supabase
        .from("participants")
        .select("user_id, active, users(username)")
        .eq("contest_id", contest.id)
        .eq("active", true);

      if (error) throw error;

      type ParticipantWithUser = { users?: { username?: string | null } | null };
      const participantRows = ((data as ParticipantWithUser[]) || []) as ParticipantWithUser[];
      const activePlayers =
        participantRows
          .map((participant) => participant.users?.username || "")
          .filter((name): name is string => Boolean(name)) || [];
      setPlayers(activePlayers);
    } catch (err) {
      console.error("Failed to fetch participants:", (err as Error).message);
    }
  }, [contest?.id]);

  const setupRealtimeListener = useCallback(() => {
    if (!contest?.id) return null;
    return supabase
      .channel(`contest-updates-${contest.id}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "contests",
          filter: `id=eq.${contest.id}`,
        },
        (payload: { new: ContestRow }) => {
          const updatedContest = payload.new;
          if (updatedContest?.submission_open) {
            navigate("/question", { state: { contest: updatedContest } });
          }
        }
      )
      .subscribe();
  }, [contest, navigate]);

  // Listen for updates to 'submission_open' in the current contest
  useEffect(() => {
    if (!contest?.id) return;

    let subscription: ReturnType<typeof setupRealtimeListener> | null = null;

    const checkSubmissionOpen = async () => {
      try {
        const { data, error } = await supabase
          .from("contests")
          .select("submission_open")
          .eq("id", contest.id)
          .single();

        if (error) {
          console.error("Error fetching contest:", error);
          return;
        }

        if (data?.submission_open) {
          navigate("/question", { state: { contest } });
        } else {
          subscription = setupRealtimeListener();
          fetchParticipants();
        }
      } catch (err) {
        console.error("Failed to check submission_open:", (err as Error).message);
      }
    };

    checkSubmissionOpen();

    return () => {
      if (subscription) {
        supabase.removeChannel(subscription);
      }
    };
  }, [contest, contest?.id, fetchParticipants, navigate, setupRealtimeListener]);

  // Update countdown timer
  useEffect(() => {
    if (!contest?.start_time) return;

    const contestStartTime = new Date(contest.start_time).getTime();

    const updateTimer = () => {
      const remaining = calculateTimeRemaining(contestStartTime);
      setTimeRemaining(remaining);

      if (remaining <= 0) {
        setTimeRemaining(0); // Prevent negative values
        if (timerRef) clearInterval(timerRef);
      }
    };

    const timerRef = setInterval(updateTimer, 1000);

    updateTimer(); // Set initial timer value

    return () => clearInterval(timerRef);
  }, [contest?.start_time]);

  // Helper functions
  function calculateTimeRemaining(startTime: number) {
    const now = new Date().getTime();
    return Math.max(startTime - now, 0); // Ensure no negative values
  }

  function formatTime(ms: number) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${seconds
      .toString()
      .padStart(2, "0")}`;
  }

  if (!contest) {
    return <div>Loading contest details...</div>;
  }

  return (
    <div className={styles.lobbyScreen}>
      <Header />
      <div className={styles.content}>
        <div className={styles.textWithIcon}>
          <span
            className={styles.timer}
            style={{
              background: gradientStyle,
              WebkitBackgroundClip: "text",
              color: "transparent",
            }}
          >
            {formatTime(timeRemaining)}
          </span>
        </div>
        <MainText header=" " subheader="until the game starts..." gradient={gradientStyle} />
        <PlayerList players={players} />
      </div>
    </div>
  );
}

export default LobbyScreen;



=======================================
FILE: src\screens\Question\QuestionScreen.tsx
=======================================

import React, { useState, useEffect, useCallback } from "react";
import { useNavigate } from "react-router-dom";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import AnswersContainer from "../../components/AnswersContainer/AnswersContainer";
import styles from "./QuestionScreen.module.css";
import { useAuth } from "../../contexts/AuthContext";
import useRequireState from "../../hooks/useRequireState";
import { supabase } from "../../supabase";
import type { ContestRow, QuestionRow } from "../../types/sbhq";

type Question = Pick<QuestionRow, "id" | "question" | "options" | "round">;

function QuestionScreen() {
  const navigate = useNavigate();
  const { user, isLoading: authLoading } = useAuth();
  const { contest } = useRequireState<{ contest: ContestRow }>(["contest"], "/login");

  const [questions, setQuestions] = useState<Question[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [loadingQuestions, setLoadingQuestions] = useState(true);
  const [errorFetchingQuestions, setErrorFetchingQuestions] = useState<string | null>(null);
  const [currentRound, setCurrentRound] = useState<number | null>(null);

  // We'll store a local error message if an inactive user tries to submit
  const [inactiveError, setInactiveError] = useState("");

  const handleBlankSubmission = useCallback(async () => {
    if (!user?.id) return;
    try {
      const { data: participant, error: participantError } = await supabase
        .from("participants")
        .select("id, active")
        .eq("user_id", user.id)
        .eq("contest_id", contest.id)
        .single();

      if (participantError || !participant) {
        return;
      }

      const participantId = participant.id;

      const { error } = await supabase.from("answers").insert({
        contest_id: contest.id,
        participant_id: participantId,
        round: currentRound,
        answer: null,
        timestamp: new Date().toISOString(),
      });

      if (error) {
        throw new Error("Failed to submit blank answer.");
      }
    } catch (err) {
      console.error("Error submitting blank answer:", (err as Error).message);
    }
  }, [contest.id, currentRound, user?.id]);

  // 1) On mount, fetch the current contest data & questions
  useEffect(() => {
    if (!contest) {
      console.error("Contest data is missing.");
      return;
    }

    const fetchContestData = async () => {
      try {
        const { data: contestData, error: contestError } = await supabase
          .from("contests")
          .select("submission_open, current_round")
          .eq("id", contest.id)
          .single();

        if (contestError) throw contestError;

        setCurrentRound(contestData.current_round);

        if (!contestData.submission_open) {
          await handleBlankSubmission();
          navigate("/eliminated", { state: { contest } });
          return;
        }

        const { data: questionsData, error: questionsError } = await supabase
          .from("questions")
          .select("id, question, options, round")
          .eq("contest_id", contest.id)
          .eq("round", contestData.current_round);

        if (questionsError) throw questionsError;

        if (!questionsData || questionsData.length === 0) {
          setQuestions([]);
          setErrorFetchingQuestions("No questions found for this round.");
        } else {
          setQuestions(questionsData as Question[]);
        }
      } catch (err) {
        console.error("Error fetching contest data:", (err as Error).message);
        setErrorFetchingQuestions("There was an error fetching contest data.");
      } finally {
        setLoadingQuestions(false);
      }
    };

    fetchContestData();

    // Real-time subscription to see if submissions get closed for this contest
    const contestChannel = supabase
      .channel(`contest-${contest.id}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "contests",
          filter: `id=eq.${contest.id}`,
        },
        async (payload) => {
          if (payload.new.submission_open === false) {
            await handleBlankSubmission();
            navigate("/eliminated", { state: { contest } });
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(contestChannel);
    };
  }, [contest, navigate, handleBlankSubmission]);

  // 4) Handle Submit
  const handleSubmit = async (selectedAnswer: string, questionId: string) => {
    if (!user?.id) {
      setInactiveError("You must be logged in to submit.");
      return;
    }
    setInactiveError("");
  
    if (!selectedAnswer) {
      alert("Please select an answer before submitting.");
      return;
    }
  
    try {
      const { data: participant, error: participantError } = await supabase
        .from("participants")
        .select("id, active")
        .eq("user_id", user.id)
        .eq("contest_id", contest.id)
        .single();
  
      if (participantError || !participant) {
        throw new Error("Could not find participant information.");
      }
  
      if (!participant.active) {
        setInactiveError("You are no longer active in this contest.");
        return;
      }
  
      const { error: answerError } = await supabase.from("answers").insert({
        contest_id: contest.id,
        participant_id: participant.id,
        round: currentRound,
        question_id: questionId, 
        answer: selectedAnswer,
        timestamp: new Date().toISOString(),
      });
  
      if (answerError) {
        throw new Error("Failed to submit the answer.");
      }
  
      navigate("/submitted", {
        state: {
          contest,
          questionId,
          selectedAnswer,
          userId: user.id,
        },
      });
    } catch (err) {
      console.error("Error during submission:", (err as Error).message);
      alert("There was an error submitting your answer. Please try again.");
    }
  };


  // 6) Loading states
  if (authLoading) return <div>Loading user information...</div>;
  if (loadingQuestions) return <div>Loading questions...</div>;
  if (errorFetchingQuestions) return <div>Error: {errorFetchingQuestions}</div>;

  // 7) UI display
  const currentQuestion = questions[currentQuestionIndex];
  const questionText = currentQuestion
    ? currentQuestion.question
    : "No question available";
  const questionAnswers = currentQuestion ? currentQuestion.options : [];

  return (
    <div className={styles.questionScreen}>
      <div className={styles.header}>
        <Header />
      </div>
      <div className={styles.screenContent}>
        <MainText
          header={`Round ${currentRound || "..."}`}
          subheader="Choose Wisely!"
        />
        {/* Show an error if user tries to submit while inactive */}
        {inactiveError && (
          <div className={styles.errorMessage}>{inactiveError}</div>
        )}
        <div className={styles.questionBlock}>
          <div className={styles.questionText}>{questionText}</div>
          {currentQuestion && (
            <AnswersContainer
              answers={questionAnswers}
              onSubmit={(selectedAnswer: string) => handleSubmit(selectedAnswer, currentQuestion.id)}
            />
          )}
          {questions.length > 1 && (
            <div className={styles.navigationButtons}>
              <button
                className={styles.actionButton}
                onClick={() => setCurrentQuestionIndex((prev) => prev - 1)}
                disabled={currentQuestionIndex === 0}
              >
                Previous
              </button>
              <button
                className={styles.actionButton}
                onClick={() => setCurrentQuestionIndex((prev) => prev + 1)}
                disabled={currentQuestionIndex === questions.length - 1}
              >
                Next
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default QuestionScreen;



=======================================
FILE: src\screens\Submitted\SubmittedScreen.tsx
=======================================

import React, { useState, useEffect, useCallback } from "react";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import styles from "./SubmittedScreen.module.css";
import ballGif from "../../assets/ball.gif";
import { useNavigate, useLocation } from "react-router-dom";
import { supabase } from "../../supabase";
import type { ContestRow } from "../../types/sbhq";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";

function SubmittedScreen() {
  const navigate = useNavigate();
  const location = useLocation();

  const { contest, questionId, selectedAnswer } = (location.state || {}) as {
    contest?: ContestRow;
    questionId?: string;
    selectedAnswer?: string;
  };

  const [correctAnswer, setCorrectAnswer] = useState<string | null>(null);
  const [statusChecked, setStatusChecked] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasNavigated, setHasNavigated] = useState(false);

  // Validate required state and redirect if missing
  useEffect(() => {
    if (!contest?.id || !questionId || selectedAnswer === undefined) {
      navigate("/", {
        replace: true,
        state: { message: "Invalid submission data." },
      });
    }
  }, [contest, questionId, selectedAnswer, navigate]);

  // Initial fetch for the correct answer
  useEffect(() => {
    if (!questionId) return;

    const fetchCorrectAnswer = async () => {
      try {
        const { data, error } = await supabase
          .from("questions")
          .select("correct_option")
          .eq("id", questionId)
          .single();

        if (error) throw error;

        if (data?.correct_option !== null) {
          setCorrectAnswer(data.correct_option);
          setStatusChecked(true);
        }
      } catch (err) {
        console.error("Error fetching correct answer:", (err as Error).message);
        setError("Error fetching correct answer.");
      }
    };

    fetchCorrectAnswer();
  }, [questionId]);

  // Real-time listener for the correct_option field
  const setupRealtimeListener = useCallback(() => {
    if (!questionId) return undefined;

    const channel = supabase
      .channel(`question-${questionId}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "questions",
          filter: `id=eq.${questionId}`,
        },
        (payload: RealtimePostgresChangesPayload<{ correct_option: string | null }>) => {
          const updatedCorrectOption =
            (payload.new as { correct_option: string | null } | undefined)?.correct_option;

          if (updatedCorrectOption !== null && updatedCorrectOption !== undefined) {
            setCorrectAnswer(updatedCorrectOption);
            setStatusChecked(true);
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [questionId]);

  useEffect(() => {
    const cleanup = setupRealtimeListener();
    return cleanup;
  }, [questionId, setupRealtimeListener]);

  // Handle visibility changes to re-establish connection
  useEffect(() => {
    const handleVisibilityChange = async () => {
      if (document.visibilityState === "visible") {
        // Perform a manual poll to fetch the latest correct_option
        try {
          const { data, error } = await supabase
            .from("questions")
            .select("correct_option")
            .eq("id", questionId)
            .single();

          if (error) {
          console.error("Error during manual poll:", error);
          return;
        }

          if (data?.correct_option !== null) {
            setCorrectAnswer(data.correct_option);
            setStatusChecked(true);
          }

          setupRealtimeListener();
        } catch (err) {
          console.error("Error fetching correct answer during visibility check:", (err as Error).message);
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [questionId, setupRealtimeListener]);

  // Evaluate the user's answer when the correct answer is set
  useEffect(() => {
    if (statusChecked && !hasNavigated) {
      if (selectedAnswer === correctAnswer) {
        setHasNavigated(true);
        navigate("/correct", { replace: true, state: { contest, questionId } });
      } else {
        setHasNavigated(true);
        navigate("/eliminated", {
          replace: true,
          state: { contest, questionId },
        });
      }
    }
  }, [
    statusChecked,
    selectedAnswer,
    correctAnswer,
    navigate,
    contest,
    questionId,
    hasNavigated,
  ]);

  return (
    <div className={styles.submittedScreen}>
      <div className={styles.headerContainer}>
        <Header />
      </div>
      <div className={styles.mainTextContainer}>
        <MainText header="Submitted!" subheader="Awaiting Results..." />
      </div>
      <div className={styles.gifContainer}>
        <img
          src={ballGif}
          alt="Awaiting results"
          className={styles.ballGif}
          style={{ width: 250, height: 250 }}
        />
      </div>

      {/* Display error message if any */}
      {error && <p className={styles.error}>{error}</p>}
    </div>
  );
}

export default SubmittedScreen;



=======================================
FILE: src\screens\Correct\CorrectScreen.tsx
=======================================

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";

import { supabase } from "../../supabase";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import GameStatsSummary from "../../components/GameStatsSummary/GameStatsSummary";
import styles from "./CorrectScreen.module.css";

import { useAuth } from "../../contexts/AuthContext";
import useRequireState from "../../hooks/useRequireState";
import type { ContestRow } from "../../types/sbhq";

type Participant = {
  id: string;
  user_id: string;
  active: boolean;
  contest_id: string;
  elimination_round: number | null;
};

function CorrectScreen() {
  const navigate = useNavigate();

  const { contest } = useRequireState<{ contest: ContestRow }>(["contest"], "/");
  const { user, isLoading: authLoading } = useAuth();

  const [currentRound, setCurrentRound] = useState<number>(contest?.current_round ?? 1);
  const [numberOfRemainingPlayers, setNumberOfRemainingPlayers] = useState(0);
  const [loadingPlayers, setLoadingPlayers] = useState(true);

  useEffect(() => {
    if (!contest?.id) return;

    const fetchOnMount = async () => {
      try {
        const { data, error } = await supabase
          .from("contests")
          .select("submission_open, current_round")
          .eq("id", contest.id)
          .single();

        if (error) {
          console.error("Error fetching contest state on refresh:", error);
          return;
        }

        if (data?.submission_open) {
          navigate("/question", {
            replace: true,
            state: {
              contest: { ...contest, ...data },
            },
          });
        } else {
          setCurrentRound(data?.current_round || currentRound);
        }
      } catch (err) {
        console.error("Failed to fetch contest state on refresh:", (err as Error).message);
      }
    };

    fetchOnMount();
  }, [contest, contest?.id, navigate, currentRound]);

  useEffect(() => {
    if (!contest?.id || !user?.id) return;

    const fetchParticipants = async () => {
      try {
        const { data: participants, error } = await supabase
          .from("participants")
          .select("*")
          .eq("contest_id", contest.id);

        if (error) throw error;
        if (!participants) return;

        const participantRows = participants as Participant[];
        const activePlayers = participantRows.filter((p) => p.active).length;
        setNumberOfRemainingPlayers(activePlayers);

        const userParticipant = participantRows.find((p) => p.user_id === user.id);
        if (!userParticipant || !userParticipant.active) {
          navigate("/eliminated", { replace: true });
          return;
        }

        setLoadingPlayers(false);
      } catch (err) {
        console.error("Error fetching participants:", err);
        setLoadingPlayers(false);
      }
    };

    fetchParticipants();
  }, [contest, contest?.id, user?.id, navigate]);

  useEffect(() => {
    if (!contest?.id || !user?.id) return;

    const contestChannel = supabase
      .channel(`contest-${contest.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "contests",
          filter: `id=eq.${contest.id}`,
        },
        async (payload: RealtimePostgresChangesPayload<ContestRow>) => {
          const newRow = payload.new as ContestRow | undefined;
          const newSubmissionOpen = newRow?.submission_open;

          if (newSubmissionOpen === true) {
            navigate("/question", {
              replace: true,
              state: {
                contest: { ...contest, ...newRow },
              },
            });
          } else if (newRow?.current_round) {
            setCurrentRound(newRow.current_round);
          }
        }
      )
      .subscribe();

    const participantsChannel = supabase
      .channel(`participants-${contest.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "participants",
          filter: `contest_id=eq.${contest.id}`,
        },
        async () => {
          try {
            const { data: updatedParticipants, error } = await supabase
              .from("participants")
              .select("*")
              .eq("contest_id", contest.id);

            if (error || !updatedParticipants) return;

            const participantRows = updatedParticipants as Participant[];
            const activeCount = participantRows.filter((p) => p.active).length;
            setNumberOfRemainingPlayers(activeCount);

            const userParticipant = participantRows.find((p) => p.user_id === user.id);
            if (!userParticipant || !userParticipant.active) {
              navigate("/eliminated", { replace: true });
            }
          } catch (err) {
            console.error("Error refreshing participants:", err);
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(contestChannel);
      supabase.removeChannel(participantsChannel);
    };
  }, [contest, contest?.id, user?.id, navigate]);

  useEffect(() => {
    const blockBack = () => {
      window.history.pushState(null, document.title, window.location.href);
    };
    window.addEventListener("popstate", blockBack);
    return () => window.removeEventListener("popstate", blockBack);
  }, []);

  if (authLoading || loadingPlayers) {
    return <div>Loading...</div>;
  }

  return (
    <div className={styles.correctScreen}>
      <Header />
      <div className={styles.content}>
        <div className={styles.textWithIcon}>
          <span className={styles.correctText}>Correct</span>
          <span className={styles.checkMarkIcon}>✓</span>
        </div>
        <MainText
          header=""
          subheader="Stay Tuned for the Next Question..."
          gradient="linear-gradient(180deg, #01710C 0%, #54627B 100%)"
        />
      </div>
      <GameStatsSummary
        numberOfRemainingPlayers={numberOfRemainingPlayers}
        roundNumber={currentRound || 1}
        className={styles.gameStatsSummary}
      />
    </div>
  );
}

export default CorrectScreen;



=======================================
FILE: src\screens\Eliminated\EliminatedScreen.tsx
=======================================

import React, { useState, useEffect } from "react";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import styles from "./EliminatedScreen.module.css";
import { useNavigate, useLocation } from "react-router-dom";
import { supabase } from "../../supabase";
import { useAuth } from "../../contexts/AuthContext";
import type { ContestRow } from "../../types/sbhq";

function EliminatedScreen() {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();

  const { contest } = (location.state || {}) as { contest?: ContestRow };

  const [pollingCount, setPollingCount] = useState(0);
  const [hasNavigated, setHasNavigated] = useState(false);
  const maxPollingCount = 10;
  const pollingInterval = 30000;

  useEffect(() => {
    if (!contest || !user) {
      navigate("/", { replace: true });
      return;
    }

    const pollForReinstatement = async () => {
      try {
        const { data, error } = await supabase
          .from("participants")
          .select("active, elimination_round")
          .eq("user_id", user.id)
          .eq("contest_id", contest.id)
          .single();

        if (error) {
          console.error("Error fetching participant status:", error.message);
          return;
        }

        if (data?.active && data?.elimination_round === null && !hasNavigated) {
          setHasNavigated(true);
          navigate("/correct", { replace: true, state: { contest } });
        }
      } catch (err) {
        console.error("Error during polling:", (err as Error).message);
      }
    };

    const interval = setInterval(() => {
      if (pollingCount < maxPollingCount) {
        pollForReinstatement();
        setPollingCount((prev) => prev + 1);
      } else {
        clearInterval(interval);
      }
    }, pollingInterval);

    return () => clearInterval(interval);
  }, [contest, user, navigate, pollingCount, hasNavigated]);

  const gradientStyle = "linear-gradient(167deg, #710117 29.79%, #54627B 90.89%)";

  return (
    <div className={styles.eliminatedScreen}>
      <Header />
      <div className={styles.content}>
        <div className={styles.textWithIcon}>
          <span className={styles.eliminatedText}>Eliminated</span>
          <span className={styles.xIcon}>✗</span>
        </div>
        <MainText header="" subheader="Thanks for playing!" gradient={gradientStyle} />
      </div>
    </div>
  );
}

export default EliminatedScreen;



=======================================
FILE: src\screens\VerificationScreen\VerificationScreen.tsx
=======================================

import React, { useState, useEffect, useRef } from "react";
import { useNavigate } from "react-router-dom";
import Header from "../../components/Header/Header";
import MainText from "../../components/MainText/MainText";
import UsernameInput from "../../components/UsernameInput/UsernameInput";
import styles from "./VerificationScreen.module.css";
import { supabase } from "../../supabase";
import type { Role } from "../../types/sbhq";

function VerificationScreen() {
  const navigate = useNavigate();
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [userHasUsername, setUserHasUsername] = useState(false);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const [role, setRole] = useState<Role>(null);
  const hasFetchedData = useRef(false);

  useEffect(() => {
    const fetchUserData = async () => {
      if (hasFetchedData.current) return;
      hasFetchedData.current = true;

      try {
        const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
        if (sessionError || !sessionData?.session) {
          console.error("Failed to fetch session:", sessionError);
          throw new Error("Failed to get current session");
        }

        const { user } = sessionData.session;
        setCurrentUserId(user.id);

        const { data, error } = await supabase
          .from("users")
          .select("username, role")
          .eq("id", user.id)
          .single();

        if (error) throw new Error("Error checking user details in the database");

        setUserHasUsername(!!data?.username);
        setRole(data?.role);

        if (data?.username) {
          // Determine redirect path based on role
          const redirectPath = data?.role === 'admin' ? '/admin' : '/join-contests';
          setTimeout(() => {
            navigate(redirectPath);
          }, 1000);
        }
      } catch (err) {
        console.error("Error in fetchUserData:", (err as Error).message);
        setError((err as Error).message || "An unexpected error occurred.");
      } finally {
        setIsLoading(false);
      }
    };

    fetchUserData();

    return () => {
      hasFetchedData.current = false;
    };
  }, [navigate]);

  const handleUsernameSubmit = async (username: string) => {
    setIsLoading(true);
    try {
      const { error } = await supabase
        .from("users")
        .update({ username })
        .eq("id", currentUserId);

      if (error) throw new Error("Failed to save username");

      // Redirect based on role after username submission
      const redirectPath = role === 'admin' ? '/admin' : '/join-contests';
      navigate(redirectPath);
    } catch (err) {
      console.error("Error in handleUsernameSubmit:", (err as Error).message);
      setError((err as Error).message || "An unexpected error occurred.");
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div className={styles.verificationScreen}>
      <div className={styles.header}>
        <Header />
      </div>
      <div className={styles.content}>
        {userHasUsername ? (
          <MainText
            header={`Welcome Back, ${role === "admin" ? "Admin" : "User"}!`}
            subheader={`Redirecting you to ${role === 'admin' ? 'the admin dashboard' : 'your contests'}...`}
          />
        ) : (
          <>
            <MainText
              header="Set Your Username"
              subheader="Please choose a unique username to complete your profile."
            />
            <UsernameInput onSubmit={handleUsernameSubmit} />
          </>
        )}
        {error && <div className={styles.error}>{error}</div>}
      </div>
    </div>
  );
}

export default VerificationScreen;



=======================================
FILE: src\components\AnswerOption\AnswerOption.js
=======================================

import React, { useState } from 'react';
import styles from './AnswerOption.module.css';
import SelectionIndicator from '../SelectionIndicator/SelectionIndicator';

const AnswerOption = ({ text, isSelected, onSelect }) => {
    const [isClicked, setIsClicked] = useState(false);

    const handleClick = () => {
        setIsClicked(true);
        onSelect();
    };

    const handleTransitionEnd = () => {
        setIsClicked(false);
    };

    return (
        <div 
            className={`${styles.answerOption} ${isClicked ? styles.answerOptionClicked : ''}`} 
            onClick={handleClick} 
            onTransitionEnd={handleTransitionEnd}
        >
            <span className={styles.answerText}>{text}</span>
            <SelectionIndicator isSelected={isSelected} />
        </div>
    );
};

export default AnswerOption;



=======================================
FILE: src\components\AnswersContainer\AnswersContainer.js
=======================================

// AnswersContainer.js
import React, { useState } from 'react';
import AnswerOption from '../AnswerOption/AnswerOption'; 
import styles from './AnswersContainer.module.css';
import CustomButton from '../CustomButton/LargeButton'; 

const AnswersContainer = ({ answers, onSubmit }) => { // Accept onSubmit prop from parent
    const [selected, setSelected] = useState(null);

    const handleSelect = (index) => {
        setSelected(index);
    };

    const handleSubmit = () => {
        if (selected !== null) {
            onSubmit(answers[selected]); // Pass the selected answer to the parent's submit handler
        } else {
            alert('Please select an answer.');
        }
    };

    return (
        <div className={styles.container}>
            {answers.map((answer, index) => (
                <AnswerOption
                    key={index}
                    text={answer}
                    isSelected={selected === index}
                    onSelect={() => handleSelect(index)}
                />
            ))}
            <CustomButton 
                className={styles.customSubmit} 
                text="Submit Answer" 
                onClick={handleSubmit} 
            />
        </div>
    );
};

export default AnswersContainer;



=======================================
FILE: src\components\AuthForm\AuthForm.tsx
=======================================

import React, { useState, FormEvent } from "react";
import LargeButton from "../CustomButton/LargeButton";
import styles from "./AuthForm.module.css";
import { supabase } from "../../supabase";

function AuthForm() {
  const [email, setEmail] = useState("");
  const [successMessage, setSuccessMessage] = useState("");
  const [errorMessage, setErrorMessage] = useState("");

  const handleEmailSubmit = async (event: FormEvent) => {
    event.preventDefault();
    setSuccessMessage("");
    setErrorMessage("");

    if (!email.trim()) {
      setErrorMessage("Email is required.");
      return;
    }

    try {
      const redirectUrl = process.env.REACT_APP_REDIRECT_URL;

      const { error } = await supabase.auth.signInWithOtp({
        email,
        options: {
          shouldCreateUser: true,
          emailRedirectTo: redirectUrl,
        },
      });

      if (error) {
        throw error;
      }

      setSuccessMessage(
        "Magic link sent! Check your email to log in or register."
      );
    } catch (error: unknown) {
      if (error instanceof Error) {
        setErrorMessage(error.message || "Failed to send magic link.");
      } else {
        setErrorMessage("Failed to send magic link.");
      }
    }
  };

  const handleGoogleSignIn = async () => {
    try {
      const { error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: process.env.REACT_APP_REDIRECT_URL,
        },
      });

      if (error) {
        throw error;
      }
    } catch (error: unknown) {
      if (error instanceof Error) {
        setErrorMessage(error.message || "Failed to sign in with Google.");
      } else {
        setErrorMessage("Failed to sign in with Google.");
      }
    }
  };

  return (
    <div className={styles.authFormContainer}>
      <button
        className={styles.googleButton}
        onClick={handleGoogleSignIn}
        type="button"
      >
        Continue with Google
      </button>
      <div className={styles.divider}>
        <span>or</span>
      </div>
      <form className={styles.form} onSubmit={handleEmailSubmit}>
        <input
          className={styles.inputField}
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
          required
        />
        {errorMessage && <div className={styles.error}>{errorMessage}</div>}
        {successMessage && <div className={styles.success}>{successMessage}</div>}
        <LargeButton text="Send Magic Link" type="submit" />
      </form>
    </div>
  );
}

export default AuthForm;



=======================================
FILE: src\components\ContestCard\ContestCard.js
=======================================

import React from "react";
import { parseISO } from "date-fns";
import { formatInTimeZone } from "date-fns-tz"; // Correct import
import styles from "./ContestCard.module.css";

function ContestCard({ contest, onJoin, isRegistered }) {
  let formattedTime;
  try {
    const date = parseISO(contest.start_time); // Parse ISO string to Date
    const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone; // Get user timezone
    formattedTime = formatInTimeZone(date, userTimeZone, "MM/dd @ h:mm a"); // Format date in user's local time
  } catch (error) {
    console.error("Error formatting date:", contest.start_time, error);
    formattedTime = "Invalid date";
  }

  return (
    <div className={styles.contestCard}>
      <div className={styles.contentGroup}>
        <h2 className={styles.title}>{contest.name}</h2>
        <p className={styles.time}>{formattedTime}</p>
        {isRegistered ? (
          <button
            className={`${styles.joinButton} ${styles.registeredButton}`}
            disabled
          >
            Registered
          </button>
        ) : (
          <button
            className={styles.joinButton}
            onClick={() => onJoin(contest.id)}
          >
            Join Contest
          </button>
        )}
      </div>
    </div>
  );
}

export default ContestCard;



=======================================
FILE: src\components\CustomButton\LargeButton.tsx
=======================================

import React from 'react';
import styles from './LargeButton.module.css';

interface CustomButtonProps {
  text: string;
  onClick?: () => void;
  className?: string;
  id?: string;
  type?: 'button' | 'submit' | 'reset';
}

const CustomButton = ({ text, onClick, className, id, type = 'button' }: CustomButtonProps) => {
  return (
    <button id={id} type={type} className={`${styles.custom} ${className || ''}`} onClick={onClick}>
      {text}
    </button>
  );
};

export default CustomButton;



=======================================
FILE: src\components\GameStatsSummary\GameStatsSummary.tsx
=======================================

import React from 'react';
import styles from './GameStatsSummary.module.css';
import DollarSignIcon from '../../assets/DollarSignIcon.svg';
import LeaderboardIcon from '../../assets/leaderboard.svg';
import PersonIcon from '../../assets/person.svg';

interface GameStatsSummaryProps {
  numberOfRemainingPlayers: number;
  roundNumber: number;
  className?: string;
}

function GameStatsSummary({ numberOfRemainingPlayers, roundNumber, className }: GameStatsSummaryProps) {
  const chanceOfWinning =
    numberOfRemainingPlayers > 0 ? ((1 / numberOfRemainingPlayers) * 100).toFixed(2) : '0.00';

  return (
    <div className={`${styles.statsSummary} ${className || ''}`}>
      <div className={styles.statItem}>
        <img src={PersonIcon} alt="Person Icon" className={styles.icon} />
        <span className={styles.text}>{numberOfRemainingPlayers} players remaining</span>
      </div>
      <div className={styles.statItem}>
        <img src={LeaderboardIcon} alt="Leaderboard Icon" className={styles.icon} />
        <span className={styles.text}>Round {roundNumber}</span>
      </div>
      <div className={styles.statItem}>
        <img src={DollarSignIcon} alt="Dollar Sign Icon" className={styles.icon} />
        <span className={styles.text}>{chanceOfWinning}% Chance of Winning</span>
      </div>
    </div>
  );
}

export default GameStatsSummary;



=======================================
FILE: src\components\Header\Header.tsx
=======================================

import React from "react";
import styles from "./Header.module.css";
import { useAuth } from '../../contexts/AuthContext';

import MySvgComponent from "../SVG";

function Header() {
  const { user } = useAuth();

  return (
    <header className={styles.header}>
      <div className={styles.icons}>
        <MySvgComponent iconType="trophy" height="16px" width="16px" />
        <div style={{ fontSize: '14px' }}>Superbowl HQ</div>
      </div>
      <div className={styles.userName}>
        {user ? user.user_metadata?.full_name || user.email || 'User' : 'Guest'}
      </div>
    </header>
  );
}

export default Header;



=======================================
FILE: src\components\MainText\MainText.tsx
=======================================

import React, { CSSProperties } from 'react';
import { Link } from 'react-router-dom';
import styles from './MainText.module.css';

interface MainTextProps {
  header: string;
  subheader: string;
  linkPath?: string;
  linkText?: string;
  gradient?: string;
  headerStyle?: CSSProperties;
}

function MainText({ header, subheader, linkPath, linkText, gradient, headerStyle }: MainTextProps) {
  const textStyle = gradient
    ? {
        background: gradient,
        color: 'transparent',
        WebkitBackgroundClip: 'text',
        backgroundClip: 'text',
      }
    : {};

  return (
    <div className={styles.mainText}>
      <div className={styles.header} style={{ ...textStyle, ...headerStyle }}>
        {header}
      </div>
      <div className={styles.subheader} style={textStyle as CSSProperties}>
        {subheader}
        {linkPath && linkText && (
          <Link to={linkPath} className={styles.link}>
            {linkText}
          </Link>
        )}
      </div>
    </div>
  );
}

export default MainText;



=======================================
FILE: src\components\PinInput\PinInput.tsx
=======================================

import React, { useState, createRef, ChangeEvent, KeyboardEvent } from 'react';
import styles from './PinInput.module.css';

interface PinInputProps {
  onPinComplete: (pin: string) => void;
}

function PinInput({ onPinComplete }: PinInputProps) {
  const [pins, setPins] = useState<string[]>(Array(6).fill(''));
  const inputRefs = Array.from({ length: 6 }, () => createRef<HTMLInputElement>());

  const handlePinChange = (index: number, value: string) => {
    if (!value.match(/[0-9]/) && value !== '') return; // Ensure only numbers are allowed

    const newPins = [...pins];
    newPins[index] = value;
    setPins(newPins);

    if (value && index < 5) {
      inputRefs[index + 1].current?.focus();
    }

    if (newPins.every((pin) => pin.length === 1)) {
      onPinComplete(newPins.join(''));
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>, index: number) => {
    if (e.key === 'Backspace' && !pins[index] && index > 0) {
      inputRefs[index - 1].current?.focus();
    }
  };

  return (
    <div className={styles.pinInputContainer}>
      {pins.map((pin, index) => (
        <input
          key={index}
          ref={inputRefs[index]}
          type="text"
          value={pin}
          onChange={(e: ChangeEvent<HTMLInputElement>) => handlePinChange(index, e.target.value)}
          onKeyDown={(e) => handleKeyDown(e, index)}
          className={styles.pinInputField}
          maxLength={1}
          autoComplete="off"
        />
      ))}
    </div>
  );
}

export default PinInput;



=======================================
FILE: src\components\PlayersList\PlayersList.tsx
=======================================

import React from 'react';
import styles from './PlayersList.module.css';

interface PlayersListProps {
  players: string[];
}

function PlayersList({ players }: PlayersListProps) {
  const MAX_VISIBLE_PLAYERS = 20;
  const visiblePlayers = players.slice(0, MAX_VISIBLE_PLAYERS);
  const remainingCount = Math.max(0, players.length - MAX_VISIBLE_PLAYERS);

  return (
    <div className={styles.playerListContainer}>
      <h2 className={styles.header}>{players.length} Players in lobby</h2>
      <div className={styles.playerGrid}>
        {visiblePlayers.map((player, index) => (
          <span key={index} className={styles.player}>
            {player}
          </span>
        ))}
        {remainingCount > 0 && <span className={styles.player}>+{remainingCount} more</span>}
      </div>
    </div>
  );
}

export default PlayersList;



=======================================
FILE: src\components\SelectionIndicator\SelectionIndicator.js
=======================================

import React from 'react';
import styles from './SelectionIndicator.module.css';

const SelectionIndicator = ({ isSelected }) => {
    return (
        <div className={styles.outerRing}>
            {isSelected && <div className={styles.innerDot}></div>}
        </div>
    );
};

export default SelectionIndicator;



=======================================
FILE: src\components\UsernameInput\UsernameInput.js
=======================================

import React, { useState } from "react";
import LargeButton from "../CustomButton/LargeButton";
import styles from "./UsernameInput.module.css";

function UsernameInput({ onSubmit }) {
  const [username, setUsername] = useState("");
  const [error, setError] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!username.trim()) {
      setError("Username cannot be empty.");
      return;
    }
    setError("");
    onSubmit(username.trim());
  };

  return (
    <form className={styles.form} onSubmit={handleSubmit}>
      <input
        className={styles.inputField}
        type="text"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="Enter your username"
      />
      {error && <div className={styles.error}>{error}</div>}
      <LargeButton 
        text="Save Username"
        type="submit"
      />
    </form>
  );
}

export default UsernameInput;



=======================================
FILE: Project-Specs.md
=======================================

## Project Overview for the SBHQ App

### The Idea:

The app is a **live sports-prop quiz platform** where users register, join live "quiz lobbies" (structured as matches), and compete by answering real-time sports-related prop questions. The unique aspect of this app is the role of the **Game Master**, who dynamically controls the flow of questions and submissions during live events. The goal should be to be able to handle a lobby of 100-1000 users simultaneously, without crashes.

### How It Works:

1. **Live Quiz Lobbies**: Users register and join a live quiz lobby. Each lobby corresponds to a live sports event or match.
2. **Game Master Controls**: The Game Master poses prop-based questions to users in real-time. For example:
   - **Question**: "What will be the first play of the drive?"
   - **Options**: "Run" or "Pass"
3. **User Submissions**: Users select their answers within a time window controlled by the Game Master.
   - Submissions are locked when the Game Master closes the question.
4. **Waiting for Results**: Once users submit answers, everyone waits for the actual event (e.g., the first play of the drive) to occur in the live sports match.
5. **Game Master Validation**: After the event occurs, the Game Master submits the correct answer (e.g., "Run").
6. **Advancement/Elimination**: Based on their answers:
   - Users who answered correctly advance to the next question.
   - Users who answered incorrectly are eliminated.

This process repeats until only one winner remains or the event ends.

### Key Aspects:

- **Interactive and Dynamic**: The Game Master’s control ensures a highly engaging and flexible experience.
- **Sports-Prop Focus**: The questions revolve around live sports betting-style props, making it unique and appealing to sports fans.
- **Real-Time Engagement**: Users are actively involved in every stage, from answering questions to awaiting results tied to real-world events.

### Technology Stack:

1. **Frontend**:
   - **React**: For building a responsive, real-time user interface.
2. **Backend**:
   - **Supabase**: For handling real-time updates for lobbies, questions, submissions, and results.
   - **Supabase Authentication**: For secure user login and registration.
   - **Supabase Functions (Optional / Likely not needed)**: For server-side logic, such as result processing or analytics.
3. **Development Tools**:
   - **Version Control**: Using GitHub/Git for collaboration and tracking.

### User Flow

#### **1. Registration and Login**
- **Step 1.1**: User logs in using Firebase phone-based authentication.
- **Step 1.2**: After login:
  - If the user is registered for a contest where the **pregame lobby** is open, they are redirected directly to the lobby.
  - If the contest has started, they are directed to the active contest screen.
    - **Missed Questions**: If the user has missed any rounds, they are marked eliminated.
    - **Connection Drops**: If the user was still active, they can rejoin the contest at their current round.

#### **2. Pregame Lobby**
- **Step 2.1**: Users in the pregame lobby see:
  - A countdown to the contest start time.
  - The number of participants currently in the lobby.

#### **3. Answering Questions**
- **Step 3.1**: The Game Master posts a question in real-time.
  - Users are shown:
    - The question text.
    - Multiple-choice options.
- **Step 3.2**: Users select their answers and are redirected to the **Submitted Screen**.

#### **4. Results and Progression**
- **Step 4.1**: Once the Game Master submits the correct answer:
  - **Eliminated Users**: Redirected to the **Eliminated Screen**.
  - **Correct Users**: Redirected to the **Correct Screen**.
- **Step 4.2**: Users remain on the Correct Screen until the Game Master updates the game round and specifies a new question.

#### **5. Contest Completion**
- **Step 5.1**: The contest ends when:
  - Only one user remains (winner).
  - All rounds are completed.
- **Step 5.2**: Winner is shown on a **Winner Screen** (optional addition).

### Admin Dashboard

The **Admin Dashboard** is a critical feature that allows the Game Master to control the flow of the live quiz. It provides tools to manage contests, questions, and participants in real-time. Its important that there is some authentication for this screen, it can be somehting as simple as just a password Below is a breakdown of its functionalities:

#### **1. Contest Management**
- **Create Contests**:
  - Admin can create a new contest by providing:
    - Contest name.
    - Start time (timestamp).
    - Entry fee (if applicable).
- **View/Edit Active Contests**:
  - See all active contests and their current statuses (e.g., `lobbyOpen`, `submissionOpen`, `currentRound`).
  - Update contest details, such as closing the lobby or marking the contest as finished.

#### **2. Question Management**
- **Add Questions**:
  - Admin can add questions to a specific contest. Each question includes:
    - Question text.
    - Multiple-choice options.
    - The round number it belongs to.
- **Manage Questions**:
  - Admin can edit or delete questions before the contest begins.
  - During the contest, the Game Master selects and activates a question for users to answer.

#### **3. Real-Time Control**
- **Open/Close Submission Window**:
  - Admin can manually open and close the submission window for each round.
- **Submit Correct Answer**:
  - After the live event occurs, the admin inputs the correct answer for the active question.
- **Update Round**:
  - Once the results are processed, the admin advances the game to the next round by specifying the next question.

#### **4. Participant Management**
- **View Participants**:
  - Admin can view all participants registered for a contest and their statuses (e.g., active, eliminated).
- **Deactivate/Reactivate Participants**:
  - Optionally, the admin can manually mark a user as eliminated (e.g., for rule violations).

#### **5. Monitor Progress**
- **Live Round Overview**:
  - A summary screen displays:
    - Current question.
    - Number of users who have submitted answers.
    - Number of active participants remaining.
### Database Schema

#### Tables

1. **`users`**:
   - **Columns**:
     - `id` (UUID, primary key, linked to `auth.users.id` for authentication)
     - `username` (text)
     - `created_at` (timestamp)
     - `updated_at` (timestamp)
     - `email` (text)
     - `role` (text, e.g., admin/user)

2. **`contests`**:
   - **Columns**:
     - `id` (UUID, primary key)
     - `name` (text)
     - `current_round` (integer)
     - `finished` (boolean)
     - `lobby_open` (boolean)
     - `submission_open` (boolean)
     - `start_time` (timestamptz)
     - `price` (numeric)
     - `created_at` (timestamp)
   - **Relationships**:
     - Links to `questions` and `participants`.

3. **`participants`**:
   - **Columns**:
     - `id` (UUID, primary key)
     - `contest_id` (UUID, foreign key, references `contests.id`)
     - `user_id` (UUID, foreign key, references `users.id`)
     - `active` (boolean)
     - `elimination_round` (integer)

4. **`questions`**:
   - **Columns**:
     - `id` (UUID, primary key)
     - `contest_id` (UUID, foreign key, references `contests.id`)
     - `round` (integer)
     - `question` (text)
     - `options` (JSONB)
     - `correct_option` (text)

5. **`answers`**:
   - **Columns**:
     - `id` (UUID, primary key)
     - `participant_id` (UUID, foreign key, references `participants.id`)
     - `round` (integer)
     - `answer` (text)
     - `timestamp` (timestamp)
     - `contest_id` (UUID, foreign key, references `contests.id`)
     - `question_id` (UUID, foreign key, references `questions.id`)

#### Relationships

1. **`users` ↔ `participants`**:
   - `participants.user_id` references `users.id`.

2. **`contests` ↔ `participants`**:
   - `participants.contest_id` references `contests.id`.

3. **`contests` ↔ `questions`**:
   - `questions.contest_id` references `contests.id`.

4. **`participants` ↔ `answers`**:
   - `answers.participant_id` references `participants.id`.

5. **`questions` ↔ `answers`**:
   - `answers.question_id` references `questions.id`.

6. **`contests` ↔ `answers`**:
   - `answers.contest_id` references `contests.id`.






=======================================
FILE: README.md
=======================================

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


```
```
sbhq
├─ package-lock.json
├─ package.json
├─ Project-Specs.md
├─ public
│  ├─ android-chrome-192x192.png
│  ├─ android-chrome-512x512.png
│  ├─ apple-touch-icon.png
│  ├─ favicon-16x16.png
│  ├─ favicon-32x32.png
│  ├─ favicon.ico
│  ├─ index.html
│  ├─ manifest.json
│  ├─ robots.txt
│  └─ site.webmanifest
├─ README.md
├─ src
│  ├─ assets
│  │  ├─ ball.gif
│  │  ├─ catch_nobg.gif
│  │  ├─ check.svg
│  │  ├─ DollarSignIcon.svg
│  │  ├─ gear.svg
│  │  ├─ hidepass.svg
│  │  ├─ leaderboard.svg
│  │  ├─ person.svg
│  │  ├─ triangle.svg
│  │  ├─ trophy.png
│  │  ├─ trophy.svg
│  │  └─ x.svg
│  ├─ components
│  │  ├─ admin
│  │  │  ├─ ContestDetail
│  │  │  │  ├─ InContestScreen.js
│  │  │  │  └─ InContestScreen.module.css
│  │  │  ├─ CreateContestModal
│  │  │  │  ├─ CreateContestModal.js
│  │  │  │  └─ CreateContestModal.module.css
│  │  │  ├─ InContest
│  │  │  │  ├─ CurrentQuestionView
│  │  │  │  │  ├─ CurrentQuestionView.js
│  │  │  │  │  └─ CurrentQuestionView.module.css
│  │  │  │  ├─ QuestionList
│  │  │  │  │  ├─ QuestionList.js
│  │  │  │  │  └─ QuestionList.module.css
│  │  │  │  ├─ QuestionModal
│  │  │  │  │  ├─ QuestionModal.js
│  │  │  │  │  └─ QuestionModal.module.css
│  │  │  │  ├─ StatCard
│  │  │  │  │  ├─ StatCard.js
│  │  │  │  │  └─ StatCard.module.css
│  │  │  │  └─ SubheaderToggles
│  │  │  │     ├─ SubheaderToggles.js
│  │  │  │     └─ SubheaderToggles.module.css
│  │  │  └─ Overview
│  │  │     ├─ OverviewScreen.js
│  │  │     └─ OverviewScreen.module.css
│  │  ├─ AnswerOption
│  │  │  ├─ AnswerOption.js
│  │  │  └─ AnswerOption.module.css
│  │  ├─ AnswersContainer
│  │  │  ├─ AnswersContainer.js
│  │  │  └─ AnswersContainer.module.css
│  │  ├─ AuthForm
│  │  │  ├─ AuthForm.js
│  │  │  └─ AuthForm.module.css
│  │  ├─ ContestCard
│  │  │  ├─ ContestCard.js
│  │  │  └─ ContestCard.module.css
│  │  ├─ CustomButton
│  │  │  ├─ LargeButton.js
│  │  │  └─ LargeButton.module.css
│  │  ├─ GameStatsSummary
│  │  │  ├─ GameStatsSummary.js
│  │  │  └─ GameStatsSummary.module.css
│  │  ├─ Header
│  │  │  ├─ Header.js
│  │  │  └─ Header.module.css
│  │  ├─ MainText
│  │  │  ├─ MainText.js
│  │  │  └─ MainText.module.css
│  │  ├─ PinInput
│  │  │  ├─ PinInput.js
│  │  │  └─ PinInput.module.css
│  │  ├─ PlayersList
│  │  │  ├─ PlayersList.js
│  │  │  └─ PlayersList.module.css
│  │  ├─ ProtectedRoute
│  │  │  └─ ProtectedRoute.js
│  │  ├─ SelectionIndicator
│  │  │  ├─ SelectionIndicator.js
│  │  │  └─ SelectionIndicator.module.css
│  │  ├─ SVG.js
│  │  └─ UsernameInput
│  │     ├─ UsernameInput.js
│  │     └─ UsernameInput.module.css
│  ├─ contexts
│  │  ├─ AuthContext.js
│  │  └─ UserContext.js
│  ├─ hooks
│  │  ├─ useCheckElimination.js
│  │  └─ useRequireState.js
│  ├─ index.css
│  ├─ index.js
│  ├─ logo.svg
│  ├─ reportWebVitals.js
│  ├─ screens
│  │  ├─ Admin
│  │  │  ├─ AdminScreen.js
│  │  │  └─ AdminScreen.module.css
│  │  ├─ Auth
│  │  │  ├─ AuthScreen.js
│  │  │  └─ AuthScreen.module.css
│  │  ├─ Correct
│  │  │  ├─ CorrectScreen.js
│  │  │  └─ CorrectScreen.module.css
│  │  ├─ Eliminated
│  │  │  ├─ EliminatedScreen.js
│  │  │  └─ EliminatedScreen.module.css
│  │  ├─ JoinContests
│  │  │  ├─ JoinContestsScreen.js
│  │  │  └─ JoinContestsScreen.module.css
│  │  ├─ Lobby
│  │  │  ├─ LobbyScreen.js
│  │  │  └─ LobbyScreen.module.css
│  │  ├─ Pregame
│  │  │  ├─ PregameScreen.js
│  │  │  └─ PregameScreen.module.css
│  │  ├─ Question
│  │  │  ├─ QuestionScreen.js
│  │  │  └─ QuestionScreen.module.css
│  │  ├─ Submitted
│  │  │  ├─ SubmittedScreen.js
│  │  │  └─ SubmittedScreen.module.css
│  │  └─ VerificationScreen
│  │     ├─ VerificationScreen.js
│  │     └─ VerificationScreen.module.css
│  ├─ setupTests.js
│  └─ supabase.js
└─ structure
   ├─ .project_structure_filter
   ├─ .project_structure_ignore
   └─ project_structure_filtered.txt

```



